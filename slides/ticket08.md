# Экзаменационный билет №8

## 1. Роль гипотез о росте структур при разработке систем управления памятью путем перепаковки на примере работы с N стеками.

Гипотезы о поведении структур служат основой для принятия решений о распределении памяти.

Формирование гипотез происходит в результате теоретического анализа модели решаемой задачи или может быть выполнено на основе статистических данных, получаемых в ходе вычислительных экспериментов с проектируемой программной системой.

**Гипотеза 1**: Стеки используются с одинаковой интенсивностью, память разделяется между стеками поровну.

**Гипотеза 2**: Интенсивность использования стеков различается.

- Конструктивное предположение о характере такой неравномерности может состоять в гипотезе сохранения локальных тенденций роста стеков
  - в каждый момент времени использование стеков на последующих шагах вычислений характеризуется точно таким же поведением, что и на предшествующих этапах обработки данных.
- Сохранение локальных тенденций роста:

  - показатель роста стека (дельта, похожая на б) = max( 0, DataCount' i – DataCounti)
  - суммарный показатель роста (дельта в виде треугольника) = сумма дельт, похожих на б итых с, 0 < i < N
  - правило распределение памяти для стеков в соответствии с их показателями роста


  ```
  Li'k = Li'k-1 + (Hik-1 - Lik-1 + 1) + F * ((дельта, похожая на б итая) / (дельта в виде треугольника)),  1 < k < N
  ```

**Гипотеза 3**: Использование вероятностных предположений о поведении стеков.

- Пусть есть (тета), 0 < (тета) < 1
- вероятность выполнимости гипотезы сохранения локальных тенденций роста. Тогда

```
Li'k = Li'k-1 + (Hik-1 - Lik-1 + 1) + (1-тета) * (F / N) + тета * F * ((дельта, похожая на б итая) / (дельта в виде треугольника)),  1 < k < N.
```

## 2. Структура хранения множеств.

**Множество** – набор элементов

### Операции над множествами

<!-- TODO:
- Add picture from metodichka -->

- проверка наличия элемента aA,
  - Получить значение бита n
  - при условии, если бит больше -1 и меньше количества битов
  - в противном случае возвращается 0

```C++
int TBitField::GetBit(const int n) const
{
	if ((n > -1) && (n < BitLen))
		return (pMem[(GetMemIndex(n))] & (GetMemMask(n)));
	else return(0);
}
```

- добавление элемента A + a
  - Установление бита
    - происходит в позицию n том случае, если бит больше -1 и меньше количества битов.

```C++
void TBitField::SetBit(const int n)
{	if ((n > -1) && (n < BitLen))
		pMem[(GetMemIndex(n))] |= GetMemMask(n);
}
```

- удаление элемента A –a.
  - Удалить бит в позиции n
    - при условии, если бит больше -1 и меньше количества битов:

```C++
void TBitField::ClrBit(const int n)
{	if ((n > -1) && (n < BitLen))
		pMem[(GetMemIndex(n))] &= ~GetMemMask(n);
}
```

### Теоретико-множественные операции

- объединение AB,
  - Операция "или" для двух битовых полей
    - осуществляется с помощью сравнивания двух полей
    - результирующее будет с длиной наибольшего из них
  - Затем последовательно выполняется дизъюнкция для i-ых элементов двух массивов

```C++
TBitField TBitField::operator|(const TBitField& bf)
{	int i, len;
	if (BitLen > bf.BitLen)
		len = BitLen;
	else len = bf.BitLen;
	TBitField temp(len);
	for (i = 0; i < MemLen; i++)
		temp.pMem[i] = pMem[i];
	for (i = 0; i < bf.MemLen; i++)
		temp.pMem[i] |= bf.pMem[i];
	return temp;
}
```

- пересечение AB
  - Операция "и" для двух битовых полей
    - осуществляется с помощью сравнивания двух полей
    - результирующее будет с длиной наименьшего из них
  - Затем последовательно выполняется конъюнкция для i-ых элементов двух массивов

```C++
TBitField TBitField::operator&(const TBitField& bf)
{
    int i, len;
	if (BitLen < bf.BitLen)
		len = BitLen;
	else len = bf.BitLen;
	TBitField temp(len);
	for (i = 0; i < MemLen; i++)
		temp.pMem[i] = pMem[i];
	for (i = 0; i < bf.MemLen; i++)
		temp.pMem[i] &= bf.pMem[i];
	return temp;
}
```

- вычитание A \ B
  - Для отрицания последовательно выполняется инверсия для каждого бита массива

```C++
TBitField TBitField::operator~(void)
{	TBitField temp(BitLen);
	for (int i = 0; i < MemLen; i++)
		temp.pMem[i] = ~pMem[i];
	return temp;
}
```

**Универс** U – множество всех элементов

- элементы множества проиндексированы (каждому элементу соответствует уникальный индекс)
- множество индексов элементов составляют непрерывный диапазон целых значений
- Тогда любое множество A (<!-- TODO find this symbol -->) U может быть описано характеристическим вектором a=(a1 a2 … an) при ai = 1
  - если ai принадлежит A, ai = 0 иначе
- Множество → битовая строка → массив битовых элементов → оперативная память (обратный порядок хранения)
- Нумерация бит в битовой строке – слева направо
- Нумерация элементов в массиве – слева направо, биты элемента – справа налево
- Байты двухбайтового элемента располагаются в ОП в обратном порядке (сначала байт с младшими битами, затем байт со старшими битами)
